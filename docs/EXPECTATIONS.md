# 框架使用与设计期望（权威规范）

本文件明确业务与框架交互的“语法与语义契约”，用于在开发中对齐共识，防止偏离需求。

## 注解放置规则
- 组件类型：在结构体上标注 `#[component]` 定义组件类型：`#[component] struct S { .. }`。
- 方法发现标记：为让宏在编译期“发现并扫描方法”，在对应的 impl 块上添加一个“发现标记” `#[component] impl S { .. }`。该标记仅用于方法扫描与生成运行循环，不改变“组件=结构体”的语义。
- 托管函数：仅对具体方法上的注解生效：
  - 被动函数：`#[handle(..)] async fn f(..)`。
  - 主动函数：`#[active(..)] async fn g(..)`。
- 未标注的方法一律视为普通工具/辅助函数，不受框架托管。
- 组件必须是结构体（struct）。

## 依赖与消息的类型化推断
- 函数参数形态：
  - `&T` 表示订阅消息类型 T（强类型订阅）。
  - 可选 `&ComponentContext` 注入运行上下文（发布、睡眠、ticker、spawn 等）。
  - 配置注入仅在 `#[init]` 中通过形参 `&CfgType` 获取；启动前通过 `App::config(CfgType { .. })` 注入；运行期只读并由组件状态持有。
- 返回值：
  - `()` 或 `Result<()>` 仅表示完成/错误。
  - `T` 或 `Result<T>` 将被自动发布为消息 T。

## 主动/被动函数
- 被动函数 `#[handle]`：由框架按强类型订阅驱动。
- 主动函数 `#[active]`：由框架调度循环；支持 `interval_ms`、`times`、`immediate` 等参数；为安全，主动函数不应要求 `&mut self`（推荐使用内部可变性）。

## 多实例与寻址
- 默认单例：同一组件类型默认仅实例化一个实例。
- 指定多实例：在组件类型上声明实例列表（按项目约定），或由应用在 `App::add_component::<T>("id")` 注册多个实例。
- 路由过滤：`#[handle(T, from=ServiceType, instance=MarkerType)]`。
  - 若仅指定 `from=Type` 而未指定 `instance`，框架会在启动时断言该 `Type` 全局只有一个实例，否则启动失败，避免歧义。

## 生命周期与边界
- 启停归一：`app.start().await?` 与 `app.stop().await`；业务无需自行管理关停通道。
- 不暴露订阅 API 给业务：业务只写函数签名与注解，框架自动接线。
- 边界：同进程强类型总线；不含网络跨进程；无背压/重试/幂等器；强类型寻址。

## 说明：为何“结构体注解”无法直接发现其方法（以及我们的选择）
- Rust 过程宏按“条目（item）”工作，结构体与实现块（impl）是不同条目，结构体上的属性宏在展开时无法遍历到后续的 impl 方法定义。
- 因此，“仅标注结构体”不足以在编译期收集方法级的 `#[handle]/#[active]` 信息；需要一种“方法级可见”的标记或注册机制。
- 解决途径（二选一）：
  1) 在 impl 上引入“仅用于发现”的标记（不改变语义，仅便于宏扫描方法并生成 run）。
  2) 让方法注解各自向全局注册，再由组件在运行时自附着订阅/任务。这通常要求方法使用 `&self`（避免跨线程的 `&mut self` 生命周期问题），并以内部可变性管理状态。

本项目采纳方案 1（impl 上的发现标记），以最小心智负担达成“函数注解即语义、未注解即普通方法”的目标。

---

本文件为项目期望与约束的唯一权威来源；若实现与此有偏差，应在发布前先行对齐或在此文件明确记录差异与演进计划。
